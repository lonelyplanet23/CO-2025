# Logisism 使用notes

## tips

1. 注意位数调整，输入位数最多是几位，就调整为几位，Alt + 1~9 快捷调整数据位宽

   <img src="C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250916184955940.png" alt="image-20250916184955940" style="zoom:50%;" />

2. ![img](https://cscore-buaa-edu-cn.vpn.buaa.edu.cn:8118/tutorial/logisim/logisim-3/assets/logisim_3_2.png)

## 陌生元器件

### Shifter 移位器

| 移位类型                         | 操作逻辑                                                     | 示例结果                    | 关键特点                                                     |
| -------------------------------- | ------------------------------------------------------------ | --------------------------- | ------------------------------------------------------------ |
| **Logical Left（逻辑左移）**     | 数据所有位向上（高位方向）移 dist 位，**低位空缺处补 0**，超出高位的 bits 直接丢弃（溢出）。 | 11001011 → 00101100         | 高位丢失，低位补 0，常用于整数 “乘以 2 的 n 次方”（n=dist）。 |
| **Logical Right（逻辑右移）**    | 数据所有位向下（低位方向）移 dist 位，**高位空缺处补 0**，超出低位的 bits 直接丢弃。 | 11001011 → 00110010         | 低位丢失，高位补 0，常用于无符号整数 “除以 2 的 n 次方”。    |
| **Arithmetic Right（算术右移）** | 数据所有位向下移 dist 位，**高位空缺处补 “数据的最高位（符号位）”**，低位超出部分丢弃。 | **110010**11 → 11**110010** | 保留符号位（最高位），适用于有符号整数的除法（避免符号错误），如补码表示的负数移位后仍为负数。 |
| **Rotate Left（循环左移）**      | 数据所有位向上移 dist 位，**高位超出的 bits 循环补到低位空缺处**（无 bits 丢失）。 | 11001011 → 00101111         | 循环复用高位，适用于需要 “位循环” 的场景（如密码算法、数据加密）。 |
| **Rotate Right（循环右移）**     | 数据所有位向下移 dist 位，**低位超出的 bits 循环补到高位空缺处**（无 bits 丢失）。 | 11001011 → 11110010         | 循环复用低位，与循环左移对应，实现位的循环移动。             |

## Negator 取反器 

+ **补码取反 = 实现数学相反数**
+ 具体方法：找到最低位的1，从这一位到最高位均取反。

## Odd /Even Parity 奇检验、偶检验

+ **与异或、同或类比**

当输入个数 = 2 时，XOR/XNOR 与奇偶校验门的结果完全相同

当输入个数＞2 时，XOR/XNOR 与奇偶校验门的逻辑规则彻底分离，文档明确了两类元件的核心区别：

| 元件类型                    | 多输入逻辑规则（输入个数 n≥3）                               | 示例（输入为 0、1、1，共 3 个输入）    |
| --------------------------- | ------------------------------------------------------------ | -------------------------------------- |
| **XOR（异或门，默认）**     | 输出 1，当且仅当 “输入中 1 的个数 = 1”（仅一个 1）；否则输出 0 | 输入 1 的个数 = 2≠1 → 输出 0           |
| **XNOR（同或门，默认）**    | 输出 1，当且仅当 “输入中 1 的个数 ≠ 1”（不是仅一个 1）；否则输出 0 | 输入 1 的个数 = 2≠1 → 输出 1           |
| **Odd Parity（奇校验门）**  | 输出 1，当且仅当 “输入中 1 的个数为奇数”（1、3、5... 个 1）；否则输出 0 | 输入 1 的个数 = 2（偶数） → 输出 0     |
| **Even Parity（偶校验门）** | 输出 1，当且仅当 “输入中 1 的个数为偶数”（0、2、4... 个 1）；否则输出 0 | 输入 1 的个数 = 2（偶数） → 输出 **1** |

## Bit Adder 



<img src="C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250916193602510.png" alt="image-20250916193602510" style="zoom:33%;" />

### **输出输入的数中有多少个1**

## Bit Finder 位查找器

+ **核心功能**：扫描多位数输入，找到符合 “Type 属性” 定义的位，并**输出该位的 “索引”**（***从最低位 0 开始计数***）。

+ 从最低位第0位开始输出（需要加一）

  

### 四种查找类型（Type）的逻辑规则

Type 属性决定了 “查找哪种位”，文档通过示例明确了四种类型的具体行为，核心是 “扫描方向”（从低到高 / 从高到低）和 “目标位值”（0/1）的组合：

| Type（查找类型）                | 扫描方向                | 目标位              | 示例输出（输入 `11010100`） | 逻辑解读（结合示例）                               |
| ------------------------------- | ----------------------- | ------------------- | --------------------------- | -------------------------------------------------- |
| **Lowest-order 1（最低位 1）**  | 从低到高（位 0 → 位 7） | 找第一个值为 1 的位 | 2                           | 位 0=0、位 1=0、位 2=1 → 第一个 1 在索引 2，输出 2 |
| **Highest-order 1（最高位 1）** | 从高到低（位 7 → 位 0） | 找第一个值为 1 的位 | 7                           | 位 7=1 → 第一个 1 在索引 7，输出 7                 |
| **Lowest-order 0（最低位 0）**  | 从低到高（位 0 → 位 7） | 找第一个值为 0 的位 | 0                           | 位 0=0 → 第一个 0 在索引 0，输出 0                 |
| **Highest-order 0（最高位 0）** | 从高到低（位 7 → 位 0） | 找第一个值为 0 的位 | 5                           |                                                    |

### 双输出逻辑：索引输出 + 状态输出

Bit Finder 有两个输出，分别承担 “结果值” 和 “结果有效性” 的反馈功能，二者需结合判断查找结果：

- **东边缘输出（索引输出）**：输出目标位的索引值（如 2、7）；若未找到目标位（如输入全 0 时找最低位 1），输出 0（仅当未找到时，此值无实际意义，需结合南边缘状态判断）。

- **南边缘输出**（状态输出）

  1 位宽，反馈查找状态：

  - 输出 `1`：成功找到目标位（如输入 `11010100` 找任意类型位，均找到）；
  - 输出 `0`：未找到目标位（所有输入位均为 “目标位的反值”，如输入全 0 找最低位 1，全 1 找最低位 0）；
  - 输出 `错误值（X）`：扫描过程中先遇到 “非 0 非 1 的位”（如浮动值、逻辑冲突的错误值），未完成查找。

- 输出前导0个数的电路：

![image-20250916192532737](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250916192532737.png)



## Comparator 比较器

###  三输出逻辑：>、=、< 分别反馈

![img](https://www.cburch.com/logisim/docs/2.7/en/img-libs/comparator.png)

Comparator 有三个独立的输出引脚，分别对应 “大于、等于、小于” 三种结果，**同一时刻仅一个输出为 1，其余为 0**（正常场景下）：

- **> 输出**：输入 1 > 输入 2 时，该引脚输出 1；否则输出 0；

- **= 输出**：输入 1 = 输入 2 时，该引脚输出 1；否则输出 0；

- **< 输出**：输入 1 < 输入 2 时，该引脚输出 1；否则输出 0。

  

## Bit Selector 位拆分器(需复习)

<img src="C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250916193637778.png" alt="image-20250916193637778" style="zoom: 50%;" />

### 划分位组，指定输出

**给定一个多位的输入，该元件会将其划分为若干个等大小的组（从最低位开始），并输出由选择输入指定的那个组**。

| 引脚类型                     | 位置               | 位宽规则                                                     | 功能描述                                                     |
| ---------------------------- | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Data Input（数据输入）**   | 西边缘（元件左侧） | 与 “Data Bits” 属性值完全一致（用户配置的输入位宽，如 8 位、16 位） | 输入需要拆分的多位数数据（如 8 位的`01010101`）。            |
| **Select Input（选择输入）** | 南边缘（元件下方） |                                                              | 输入 “位组编号”，**指定要输出的位组**（组号需在有效范围内，**否则输出全 0**）。 |
| **Group Output（位组输出）** | 东边缘（元件右侧） | 与 “Output Bits” 属性值完全一致（用户配置的输出位宽，如 3 位、8 位） | **超过最高位的都输出0**                                      |

例如，如果我们有一个 8 位的输入 `01010101`，并且要得到一个 3 位的输出

+ 那么第 0 组将是最低位的 3 位 `101`，
+ 第 1 组是接下来的 3 位 `010`
+ 第 2 组是再接下来的 3 位 `001`。（顶部之外的任何位都用 0 填充。）
+ 选择输入将是一个两位的数，用于选择要输出这三个组中的哪一个：如果选择输入是 3，那么输出将是 `000`。