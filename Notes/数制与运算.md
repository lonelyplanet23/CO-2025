# 数制与运算

## 进制转换

### 十进制转换（常见）

十进制转二进制：**短除倒取余**

- 用十进制数除以2，得到的余数就是相应二进制的最低位 
- 将得到的商继续除以2，得到的余数就是次低位 
- **重复上述过程直至商为0**

### **十六进制、八进制与二进制转换** （需要掌握）

**直接分段法：**从低位开始，每4位（或三位）二进制对应1位十六进制（八进制）

![image-20250915184211807](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250915184211807.png)

## 术语

1. 位(bit)
2. **字节(byte)：8个二进制位构成的元组，基本数据单位，0x00 - 0xff**
3. 最高有效位、最低有效位、最高/最低有效字节

## 二进制加法

+ **溢出(overflow**): 计算机计算结构位数有限，假设CPU的字长为4位，则b4位是不存在的，故计算结果就是00002，即0。

##  编码

**编码无意义，编码被赋予语义后才有意义**

### **n位B进制**

1. ###### 编码空间：有效编码的集合：$B^n$

2. **如何确定所需要的编码位数：取对数向上取整**

## 二进制有符号数的表达-补码

我的理解：将符号数范围**平移**至无符号数

![image-20250915190649328](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250915190649328.png)

**第一位-符号位**  **后n-1位-数值**

- [ ] ***n位二进制补码可以表示$-2^{n-1}    $ ~ $2^{n-1}-1$范围***

+ **计算方法：正数相同，负数各位取反再加1**
+ 正数区间与负数区间大致相同 ，**负数区间比正数区间多一个数**

## 浮点数【IEEE754】

### 本质：**科学计数法** $\pm M \times   2^E$ 

![image-20250915190933085](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250915190933085.png)

+ 1位符号

+ 8位指数 -128 ~127

+ 23位尾数（单精度符号）

**优化：尾数第一位必定为1，不占用实际储存位**

### 表示小数

偏阶计数法：编码用的指数=真实指数(补码)+127（01111111) 【再次平移,去掉溢出的数】

![image-20250915200306059](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250915200306059.png)

###  表示范围

单精度：注意最小正数哦！![image-20250915192948903](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250915192948903.png)

双精度：![image-20250915193027841](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250915193027841.png)

![image-20250915193124864](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250915193124864.png)

### 上溢：向上舍入变为±∞；下溢：向下舍入变为0



## 位扩展

（阅读）![image-20250915194147561](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250915194147561.png)

## 比较

只需实现相等（=）与小于（<）的功能

### 有符号数的小于- 扩展1位作差

+ 做差法
+ 但是会出现(0-(-8) = 8)超出了四位二进制码的范围
+ 因此**均扩展1位符号位** **进行N+1位二进制补码的减法计算**
+ 无符号数的比较扩展符号位0，转化为有符号数的比较

### 相等 -  异或 或者 作差， 然后OR起来



## 乘法-人的运算方式

### 无符号数 

+ 循环累加左移后的被乘数

```
 C = 0
 for i = 0 to M-1
	 if B[i] then
 		C = C + A << i
```

### 有符号数，先绝对值（补码相反数）相乘，后决定符号

##  除法 - 还是人的运算方式-试商法

### 无符号数

+ 商的各位非0即1，“试商”更为简单

![image-20250915195903368](C:\Users\27628\AppData\Roaming\Typora\typora-user-images\image-20250915195903368.png)

+ 中间余数减去除数，判断大小，决定商那位是1还是0

### 有符号数，先绝对值（补码相反数）作商，后决定符号